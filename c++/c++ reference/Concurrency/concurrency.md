**并发支持库**

-------------------------------------------------

c++对支持以下的操作来完成软件的并发??

1. 线程
2. 原子操作
3. 互斥
4. 条件变量
5. future

# 线程

线程使得程序可以在数个处理器核心之间同时执行

## thread 

[thread](./thread/thread.md)

## jthread

[jthread](./jthread/jthread.md)

# 原子操作

每个 std::atomic 模板的实例化和全特化定义一个原子类型。如果一个线程写入原子对象，同时另一线程从它读取，那么行为良好定义（数据竞争的细节见内存模型）。

另外，对原子对象的访问可以建立线程间同步，并按 std::memory_order 所对非原子内存访问定序。

std::atomic 既不可复制也不可移动。

## 成员类型

1、`value_type`：返回模板类型 T
2、`difference_tpe`：value_type (仅对 atomic<整数> 和atomic<浮点> (C++20 起) 特化) std::ptrdiff_t (仅对 std::atomic<U*> 特化)

## 成员函数

1. is_lock_free ： 检查原子对象是否面锁
2. store：原子地以非原子对象替换原子对象的值
3. load: 原子地获得原子对象的值
4. exchange：原子地替换原子对象的值并获得它先前持有的值
5. compare_exchange_weak ： 原子地比较原子对象与非原子参数的值，若相等则进行交换，若不相等则进行加载
5. compare_exchange_strong ：原子地比较原子对象与非原子参数的值，若相等则进行交换，若不相等则进行加载
6. fetch_add：原子地将参数加到存储于原子对象的值，并返回先前保有的值
7. fetch_sub：原子地从存储于原子对象的值减去参数，并获得先前保有的值
8. fetch_and：原子地进行参数和原子对象的值的逐位与，并获得先前保有的值
9. fetch_or：原子地进行参数和原子对象的值的逐位或，并获得先前保有的值
10. fetch_xor：原子地进行参数和原子对象的值的逐位异或，并获得先前保有的值